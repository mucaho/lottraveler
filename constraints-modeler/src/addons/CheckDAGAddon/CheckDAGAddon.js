/*globals define*/

/**
 * Generated by AddOnGenerator 1.7.0 from webgme on Wed Mar 17 2021 11:11:42 GMT+0100 (GMT+01:00).
 */

define([
    'addon/AddOnBase',
    'plugin/PluginBase',
    'plugin/util',
    'constraints-modeler/ExportFromModel',
    'constraints-modeler/CheckConstraintsInModel',
], function (AddOnBase, PluginBase, pluginUtil, ExportFromModel, CheckConstraintsInModel) {
    'use strict';

    /**
     * Initializes a new instance of CheckDAGAddon.
     * @class
     * @augments {AddOnBase}
     * @classdesc This class represents the addOn CheckDAGAddon.
     * @constructor
     */
    var CheckDAGAddon = function (mainLogger, gmeConfig) {
        // Call base class' constructor.
        AddOnBase.call(this, mainLogger, gmeConfig);
    };

    // Prototypal inheritance from AddOnBase.
    CheckDAGAddon.prototype = Object.create(AddOnBase.prototype);
    CheckDAGAddon.prototype.constructor = CheckDAGAddon;

    /**
     * Gets the name of the CheckDAGAddon.
     * @returns {string} The name of the AddOn.
     * @public
     */
    CheckDAGAddon.prototype.getName = function () {
        return 'CheckDAGAddon';
    };

    /**
     * Gets the semantic version (semver.org) of the CheckDAGAddon.
     * @returns {string} The version of the AddOn.
     * @public
     */
    CheckDAGAddon.prototype.getVersion = function () {
        return '0.1.0';
    };

    /**
     * This is invoked each time changes in the branch of the project are done. AddOns are allowed to make changes on
     * an update, but should not persist by themselves. (The AddOnManager will persist after each addOn has had its way
     * ordered by the usedAddOn registry in the rootNode).
     * Before each invocation a new updateResult is created which should be returned in the callback. There is no need
     * for the AddOn to report if it made changes or not, the monitor/manager will always persist and if there are no
     * changed objects - it won't commit to the storage.
     * @param {object} rootNode
     * @param {object} commitObj
     * @param {function(Error, AddOnUpdateResult)} callback
     */
    CheckDAGAddon.prototype.update = function (rootNode, commitObj, callback) {
        this.logger.info('CheckDAGAddon in update at commitHash', commitObj._id);

        // fake PluginBase instance members that are required by ExportFromModel
        // TODO: if rootNode does not change, maybe cache results for performance
        this.rootNode = rootNode;
        this.META = this.getMetaNodesMap(rootNode);

        // extract model and then check for cycles
        // TODO: if commit obj only contains cosmetic changes do not run validation
        ExportFromModel(this).then((model) => {
            var hasCycle = CheckConstraintsInModel.detectCycle(model);
            if (hasCycle) {
                this.logger.info('CheckDAGAddon found cycle at commitHash', commitObj._id);
                this.addNotification({ message: 'Cycle detected! Remove the offending connection(s) before continuing.', severity: 'error' });
            }

            var hasDuplicateTasks = CheckConstraintsInModel.detectDuplicateTasks(model);
            if (hasDuplicateTasks) {
                this.logger.info('CheckDAGAddon found duplicate task at commitHash', commitObj._id);
                this.addNotification({ message: 'Duplicate tasks detected! Rename the offending task(s) before continuing.', severity: 'error' });
            }

            callback(null, this.updateResult);
        });
    };

    /**
     * Called once when the addOn is started for the first time.
     * @param {object} rootNode
     * @param {object} commitObj
     * @param {function(Error, AddOnUpdateResult} callback
     */
    CheckDAGAddon.prototype.initialize = function (rootNode, commitObj, callback) {
        this.logger.info('CheckDAGAddon got initialized at commitHash', commitObj._id);

        this.update(rootNode, commitObj, callback);
    };

    // get META nodes map, required by ExportFromModel
    CheckDAGAddon.prototype.getMetaNodesMap = function (rootNode) {
        var namespace = '';
        var libraryNames = this.core.getLibraryNames(rootNode);
        if (libraryNames && libraryNames.indexOf('meta') >= 0) {
            namespace = 'meta';
        }

        // taken from PluginBase
        return pluginUtil.getMetaNodesMap(
            this.core,
            this.rootNode,
            this.logger,
            namespace
        );
    };

    // copied from PluginBase, required by ExportFromModel
    CheckDAGAddon.prototype.isMetaTypeOf = PluginBase.prototype.isMetaTypeOf;

    // copied from PluginBase, required by ExportFromModel
    CheckDAGAddon.prototype.loadNodeMap = PluginBase.prototype.loadNodeMap;

    return CheckDAGAddon;
});
